# CppPrimer第二章整理

## 目录
* [2.1基本内置类型](#基本内置类型)
* [2.2变量](#变量)
* [2.3复合类型](#复合类型)

## 基本内置类型
分为算术类型（arithmetic type）和空类型（void）
### 算术类型
算术类型分为两类：整型（包括字符和布尔类型在内）和浮点型。

C++ 算术类型表：

|类型|含义|最小尺寸
|---|---|---
|bool|布尔类型|未定义
|char|字符|8位
|wchar_t|宽字符|16位
|char16_t|Unicode字符|16位
|char32_t|Unicode字符|32位
|short|短整型|16位
|int|整型|16位
|long|长整型|32位
|long long |长整型|64位
|float|单精度浮点数|6位有效数字
|double|双精度浮点数|10位有效数字
|long double|扩展精度浮点数|10位有效数字

C++ 语言规定一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。其中，数据类型 long long 是在 C++ 11 中新定义的。

### 内置类型的机器实现
大多数计算机以 2 的整数次幂个比特作为块来处理内存，**可寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”**，它通常由几个字节组成。在 C++ 中，一个字节至少能容纳机器基本字符集中的字符。**大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。**

>建议：如何选择类型
>和 C 语言一样，C++ 的设计准则之一也是尽可能接近硬件。C++ 的算术类型必须满足各种硬件的特质，大多数程序员能够（也应该）对数据类型的使用做出限定从而简化选择的过程。以下是选择类型的一些经验准则：
>* 当明确知晓数值不可能为负时，选用无符号类型。
>* 使用 int 执行整数运算。在实际应用中， short 常常显得太小而 long 一般和 int 有一样的尺寸。如果你的数值超过了 int 的表示范围，选用 long long。
>* 在算术表达式中不要使用 char 或者 bool，只有在存放字符或布尔值时才使用它们。因为类型 char 在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用 char 进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是 signed char 或者 unsigned char。
>* 执行浮点数运算选用 double，这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。

### 类型转换
```Cpp
bool b = 42;  // b 为真
int i = b;    // i 的值为 1
i = 3.14;     // i 的值为 3
double pi = i;// pi 的值为 3.0
unsigned char c = -1; // 假设 char 占 8 比特， c  的值为 255
signed char c2 = 256; // 假设 char 占 8 比特， c2 的值是未定义的
```

* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。

* 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃、也可能产生垃圾数据。

> 程序应该尽量避免依赖于实现环境的行为。如果我们把 int 的尺寸看成是一个不变的已知值，那么这样的程序就称作**不可移植的（nonportable）** 。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。

* 当一个算术表达式中既有无符号数又有 int 时，int 值会转换成无符号数。
```Cpp
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl;  // out -84
std::cout << u + i << std::endl;  // 如果 int 占 32 位（4294967295），out 4294967264
```

* 当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负数：
```Cpp
unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl;  // out 32
std::cout << u2 - u1 << std::endl;  // err 输出为取模后的值
```
**切勿混用带符号类型和无符号类型。带符号类型会自动地转换成无符号数**

### 字面值常量
#### 转义序列
有两类字符程序员不能直接使用：一类是**不可打印（nonprintable）** 的字符，如退格符或其他控制字符，因为它们没有可视的图符；另一类是在 C++ 中有特殊含义的字符（单引号、双引号、问号、反斜线）。这些情况下需要用到**转义序列**，转义序列均以反斜线作为开始，C++ 规定的转义序列包括：

|名称|符号|名称|符号|名称|符号|
|---|---|---|---|---|---|
|换行符|\n|横向制表符|\t|报警（响铃）符|\a|
|纵向制表符|\v|退格符|\b|双引号|\\"|
|反斜线|\\\ |问号|\\?|单引号|\\'|
|回车符|\r|进纸符|\f|

> 我们也可以使用泛化的转义序列，其形式是 \x 后紧跟一个或多个十六进制数字，或者 \ 后紧跟 1 个、 2 个或 3 个八进制数字，其中数字部分表示的是字符对应的数值。假设使用的是 Latin-1 字符集，以下是一些示例。
\7(响铃) \12(换行符) \40(空格)\
\0(空字符) \115(字符M) \x4d(字符M)

* 如果反斜线 \ 后面跟着的八进制数字超过 3 个，只有前 3 个数字与 \ 构成转义序列。

#### 指定字面值的类型
```Cpp
L'a'    // 宽字符型字面值，类型是 wchar_t
u8"hi!" // utf-8 字符串字面值（utf-8 用 8 位编码一个 Unicode 字符）
42ULL   // 无符号整型字面值，类型是 unsigned long long
1E-3F   // 单精度浮点型字面值，类型是 float
3.14159L// 扩展精度浮点型字面值，类型是 long double
```

**当使用一个长整型字面值时，请使用大写字母 L 来标记，因为小写字母 l 和数字 1 太容易混淆了。**

字符和字符串字面值

|前缀|含义|类型|
|---|---|---|
|u|Unicode16字符|char16_t|
|U|Unicode32字符|char32_t|
|L|宽字符|wchar_t|
|u8|UTF-8（仅用于字符串字面常量）|char|

整型字面值和浮点型字面值

|后缀|最小匹配类型|后缀|类型|
|---|---|---|---|
|u or U|unsigned|f or F|float|
|i or L|long|l or L|long double|
|ll or LL|long long|

## 变量
### 列表初始化
以下 4 种方式都可以
```Cpp
int units_sold = 0;
int units_sold = {0};
int units_sold(0);
int units_sold{0};
```
无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。**如果使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。**

### 变量声明和定义的关系
如果想声明一个变量而非定义它，就在变量名前添加关键字 extern ，而且不要显示地初始化变量：
```Cpp
extern int i; // 声明 i 而非定义 i
int j;        // 声明并定义 j
```
任何包含了显示初始化的声明即成为定义。我们能给由 extern 关键字标记的变量赋一个初始值，但是这么做也抵消了 extern 的作用。 extern 语句如果包含初始值就不再是声明，而变成了定义了:
```Cpp
extern double pi = 3.1416;  // 定义
```
**在函数体内部，如果试图初始化一个由 extern 关键字标记的变量，将引发错误。变量能且只能被定义一次，但是可以被多次声明。**

### 标识符
标识符必须以字母或下划线开头。长度没有限制，但是对大小写字母敏感。

**不过 C++ 为标准库保留了一些名字，用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。**

### 嵌套的作用域
* 允许在内层作用域中重新定义外层作用域已有的名字。
```Cpp
#include <iostream>
// 该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量
int reused = 42;  // reused 拥有全局作用域
int main() {
    int unique = 0; // unique 拥有块作用域
    // 输出 #1: 使用全局变量 reused 输出 42 0
    std::cout << reused << " " << unique << std::endl;
    int reused = 0; // 新建局部变量 reused ，覆盖了全局变量 reused
    // 输出 #2: 使用局部变量 reused 输出 0 0
    std::cout << reused << " " << unique << std::endl;
    // 输出 #3: 显示地访问全局变量 reused; 输出 42 0
    std::cout << ::reused << " " << unique << std::endl;

    return 0;
}
```
**输出#3使用作用域操作符来覆盖默认的作用域规则，因为全局作用域本身没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。**

## 复合类型
C++中复合类型有数组、字符串、结构体、共用体、枚举、引用、指针和数组的代替品。
### 引用（左值引用）
引用并非对象，它只是为已经存在的对象所起的另外一个名字。
>为引用赋值，是把值赋给了与引用绑定的对象。获取引用的值，就是获取了与引用绑定的对象的值。同理，以引用作为初始值，是以与引用绑定的对象作为初始值。
**因为引用本身不是一个对象，所以不能定义引用的引用。**

### 指针

* 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内他可以先后指向几个不同的对象。

* 指针无需在定义时赋初值（野指针）。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

>试图拷贝或以其他方式防伪无效指针的值都将引发错误。编译器不负责检查此类错误，这一点和试图使用未经初始化的变量是一样的。访问无效指针的后果无法预计，因此程序员必须清楚任意给定的指针是否有效。

* **解引用操作仅适用于那些确实指向了某个对象的有效指针**

把 int 变量直接赋值给指针是错误的操作，即使 int 变量的值恰好等于 0 也不行。
```cpp
int zero = 0;
int *p1 = zero;
```

* **一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。**

* 以 void* 的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中的对象。

### 理解复合类型的声明
变量的定义包括一个基本数据类型和一组声明符，基本数据类型只有一个，但是声明符的形式可以不同。
```Cpp
int i = 1024, *p = &i, &r = i;
```
>类型修饰符只是声明符的一部分。

```Cpp
int* p;   // 合法但是容易产生误导
```
上面基本数据类型是 int 而非 int* ，* 仅仅是修饰了 p 而已，对该声明语句中的其他变量，并不产生任何作用：
```Cpp
int* p1, p2;  // p1 是指向 int 的指针， p2 是 int
```
### 指向指针的引用
引用本身不是一个对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用:
```Cpp
int i = 42;
int *p;       
int *&r = p;  // r 是一个对指针 p 的引用
r = &i;       // r 引用了一个指针，因此给 r 赋值 &i 就是令 p 指向 i
*r = 0;       // 解引用 r 得到 i，也就是 p 指向的对象，将 i 的值改为 0
```

>要理解 r 的类型到底是什么，最简单的方法就是从右向左阅读 r 的定义。离变量名最近的符号对变量的类型有最直接的影响。声明符的其他部分用以确定 r 引用的类型是什么，此例中的符号 * 说明 r 引用的是一个指针。最后，声明的基本数据类型部分指出 r 引用的是一个 int 指针。

### const 限定符
const 对象一旦创建后其值就不能再改变，所以 const 对象必须初始化。一如既往，初始值可以是任意复杂的表达式：
```Cpp
const int i = get_size();   // 正确，运行时初始化
const int j = 42;           // 正确，编译时初始化
const int k;                // 错误，k 是一个未经初始化的常量
```
在不改变 const 对象的操作中还有一种是初始化，如果利用一个对象去初始化另外一个对象，则他们是不是 const 都无关紧要：
```Cpp
int i = 42;
const int ci = i;   // 正确： i 的值被拷贝给了 ci
int j = ci;         // 正确： ci 的值被拷贝给了 j
```
**ci 的常量特征仅仅在执行改变 ci 的操作时才会发挥作用。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。**

* **默认状态下， const 对象仅在文件内有效**

当在多个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量。

某些时候有这样一种 const 变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类 const 对象像其他对象一样工作，也就是说，**只在一个文件中定义 const，而在其他多个文件中声明并使用它。解决的办法是：对于 const 变量不管是声明还是定义都添加 extern 关键字，这样，只需定义一次就可以了:**
```Cpp
// file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问
extern const int buf_size = fcb();
// file_1.h 头文件
extern const int buf_size;  // 与 file_1.cc 中定义的 buf_size 是同一个
```

### const 的引用
可以把引用绑定到 const 对象上，我们称之为对常量的引用，不能被用作修改它所绑定的对象。

* 常量引用是对 const 的引用
>对 const 的引用 经常被简称为常量引用。严格来说，并不存在常量引用。因为**引用不是一个对象**，所以我们设法让引用本身恒定不变。由于 C++ 语言并不允许随意改变引用所绑定的对象，所以从这层意义上理解所有的引用又都算作常量。

#### 初始化和对 const 的引用
引用的类型必须与其所引用的类型一致，但是有两个例外
* 第一种例外情况是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象，字面值，甚至是一般表达式：
```Cpp
int i = 42;
const int &r1 = i;     // 允许将 const int& 绑定到一个普通 int 对象上
const int &r2 = 42;    // 正确，r1 是一个常量引用
const int &r3 = r1 * 2;// 正确，r3 是一个常量引用
int &r4 = r1 * 2;      // 错误，r4 是一个普通的非常量引用
```
最简单的方法就是弄清楚当一个常量引用被绑定到一个另外一种类型上时到底发生了什么。
```Cpp
double dval = 3.14;
const int &ri = dval; // ri = 3;
```


111111
