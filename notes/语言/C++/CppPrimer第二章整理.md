# CppPrimer第二章整理

## 目录
* [2.1基本内置类型](#基本内置类型)
* [2.2变量](#变量)
* [2.3复合类型](#复合类型)

## 基本内置类型
分为算术类型（arithmetic type）和空类型（void）
### 算术类型
算术类型分为两类：整型（包括字符和布尔类型在内）和浮点型。

C++ 算术类型表：

|类型|含义|最小尺寸
|---|---|---
|bool|布尔类型|未定义
|char|字符|8位
|wchar_t|宽字符|16位
|char16_t|Unicode字符|16位
|char32_t|Unicode字符|32位
|short|短整型|16位
|int|整型|16位
|long|长整型|32位
|long long |长整型|64位
|float|单精度浮点数|6位有效数字
|double|双精度浮点数|10位有效数字
|long double|扩展精度浮点数|10位有效数字

C++ 语言规定一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。其中，数据类型 long long 是在 C++ 11 中新定义的。

### 内置类型的机器实现
大多数计算机以 2 的整数次幂个比特作为块来处理内存，**可寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”**，它通常由几个字节组成。在 C++ 中，一个字节至少能容纳机器基本字符集中的字符。**大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。**

>建议：如何选择类型
>和 C 语言一样，C++ 的设计准则之一也是尽可能接近硬件。C++ 的算术类型必须满足各种硬件的特质，大多数程序员能够（也应该）对数据类型的使用做出限定从而简化选择的过程。以下是选择类型的一些经验准则：
>* 当明确知晓数值不可能为负时，选用无符号类型。
>* 使用 int 执行整数运算。在实际应用中， short 常常显得太小而 long 一般和 int 有一样的尺寸。如果你的数值超过了 int 的表示范围，选用 long long。
>* 在算术表达式中不要使用 char 或者 bool，只有在存放字符或布尔值时才使用它们。因为类型 char 在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用 char 进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是 signed char 或者 unsigned char。
>* 执行浮点数运算选用 double，这是因为 float 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。long double 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。

### 类型转换
```Cpp
bool b = 42;  // b 为真
int i = b;    // i 的值为 1
i = 3.14;     // i 的值为 3
double pi = i;// pi 的值为 3.0
unsigned char c = -1; // 假设 char 占 8 比特， c  的值为 255
signed char c2 = 256; // 假设 char 占 8 比特， c2 的值是未定义的
```

* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。

* 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃、也可能产生垃圾数据。

> 程序应该尽量避免依赖于实现环境的行为。如果我们把 int 的尺寸看成是一个不变的已知值，那么这样的程序就称作**不可移植的（nonportable）** 。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。

* 当一个算术表达式中既有无符号数又有 int 时，int 值会转换成无符号数。
```Cpp
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl;  // out -84
std::cout << u + i << std::endl;  // 如果 int 占 32 位（4294967295），out 4294967264
```

* 当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负数：
```Cpp
unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl;  // out 32
std::cout << u2 - u1 << std::endl;  // err 输出为取模后的值
```
**切勿混用带符号类型和无符号类型。带符号类型会自动地转换成无符号数**

### 字面值常量
#### 转义序列
有两类字符程序员不能直接使用：一类是**不可打印（nonprintable）** 的字符，如退格符或其他控制字符，因为它们没有可视的图符；另一类是在 C++ 中有特殊含义的字符（单引号、双引号、问号、反斜线）。这些情况下需要用到**转义序列**，转义序列均以反斜线作为开始，C++ 规定的转义序列包括：

|名称|符号|名称|符号|名称|符号|
|---|---|---|---|---|---|
|换行符|\n|横向制表符|\t|报警（响铃）符|\a|
|纵向制表符|\v|退格符|\b|双引号|\\"|
|反斜线|\\\ |问号|\\?|单引号|\\'|
|回车符|\r|进纸符|\f|

> 我们也可以使用泛化的转义序列，其形式是 \x 后紧跟一个或多个十六进制数字，或者 \ 后紧跟 1 个、 2 个或 3 个八进制数字，其中数字部分表示的是字符对应的数值。假设使用的是 Latin-1 字符集，以下是一些示例。
\7(响铃) \12(换行符) \40(空格)\
\0(空字符) \115(字符M) \x4d(字符M)

* 如果反斜线 \ 后面跟着的八进制数字超过 3 个，只有前 3 个数字与 \ 构成转义序列。

#### 指定字面值的类型
```Cpp
L'a'    // 宽字符型字面值，类型是 wchar_t
u8"hi!" // utf-8 字符串字面值（utf-8 用 8 位编码一个 Unicode 字符）
42ULL   // 无符号整型字面值，类型是 unsigned long long
1E-3F   // 单精度浮点型字面值，类型是 float
3.14159L// 扩展精度浮点型字面值，类型是 long double
```

**当使用一个长整型字面值时，请使用大写字母 L 来标记，因为小写字母 l 和数字 1 太容易混淆了。**

字符和字符串字面值

|前缀|含义|类型|
|---|---|---|
|u|Unicode16字符|char16_t|
|U|Unicode32字符|char32_t|
|L|宽字符|wchar_t|
|u8|UTF-8（仅用于字符串字面常量）|char|

整型字面值和浮点型字面值

|后缀|最小匹配类型|后缀|类型|
|---|---|---|---|
|u or U|unsigned|f or F|float|
|i or L|long|l or L|long double|
|ll or LL|long long|

## 变量
### 列表初始化
以下 4 种方式都可以
```Cpp
int units_sold = 0;
int units_sold = {0};
int units_sold(0);
int units_sold{0};
```
无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。**如果使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。**

### 变量声明和定义的关系
如果想声明一个变量而非定义它，就在变量名前添加关键字 extern ，而且不要显示地初始化变量：
```Cpp
extern int i; // 声明 i 而非定义 i
int j;        // 声明并定义 j
```
任何包含了显示初始化的声明即成为定义。我们能给由 extern 关键字标记的变量赋一个初始值，但是这么做也抵消了 extern 的作用。 extern 语句如果包含初始值就不再是声明，而变成了定义了:
```Cpp
extern double pi = 3.1416;  // 定义
```
**在函数体内部，如果试图初始化一个由 extern 关键字标记的变量，将引发错误。变量能且只能被定义一次，但是可以被多次声明。**

### 标识符
标识符必须以字母或下划线开头。长度没有限制，但是对大小写字母敏感。

**不过 C++ 为标准库保留了一些名字，用户自定义的标识符中不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。**

### 嵌套的作用域
* 允许在内层作用域中重新定义外层作用域已有的名字。
```Cpp
#include <iostream>
// 该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量
int reused = 42;  // reused 拥有全局作用域
int main() {
    int unique = 0; // unique 拥有块作用域
    // 输出 #1: 使用全局变量 reused 输出 42 0
    std::cout << reused << " " << unique << std::endl;
    int reused = 0; // 新建局部变量 reused ，覆盖了全局变量 reused
    // 输出 #2: 使用局部变量 reused 输出 0 0
    std::cout << reused << " " << unique << std::endl;
    // 输出 #3: 显示地访问全局变量 reused; 输出 42 0
    std::cout << ::reused << " " << unique << std::endl;

    return 0;
}
```
**输出#3使用作用域操作符来覆盖默认的作用域规则，因为全局作用域本身没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。**

## 复合类型



111111
