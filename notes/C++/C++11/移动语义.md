# 移动语义

有一些类的资源是__不可共享__的，这种类型的对象可以被移动但不能被拷贝，如：`IO` 或 `unique_ptr`
库容器、`string` 和 `shared_ptr` 支持拷贝和移动，`IO` 和 `unique_ptr` 则只能移动不能拷贝。。

## 右值引用

右值引用是必须绑定到右值的引用，右值引用使用 ``&&`` 符号，相较于左值引用的`` &`` 。右值引用有一个特性就是其只能绑定到**即将销毁**的对象上，因而，可以自由的移动右值引用对象中的资源。

左值表示**对象的身份**，而右值表示**对象的值**。不能将左值引用（lvalue reference）绑定到需要转型的值、字面量或者返回右值的表达式上。右值引用则刚好相反：可以将右值引用绑定到以上的值，但不能直接将右值引用绑定到左值。如：

```c++
int i = 42;
int &r = i;
int &&rr = i; //错误：不能将右值引用绑定到左值上
int &r2 = i * 42; //错误：不能将左值引用绑定到右值上
const int &r3 = i * 42; //可以将 const 左值引用绑定到任何类型的值上（const/非 const 的左/右值）
int &&rr2 = i * 42; //将右值引用绑定到右值上
```

返回左值引用的函数和赋值、下标操作、解引用和前缀自增/自减操作符都是返回左值的表达式，可将左值引用绑定到这些表达式的结果中。

返回非引用类型的函数与算术、关系、位操作和后缀自增/自减的操作符都是返回右值的表达式，可将右值引用和 `const` 左值引用绑定到这种表达式上。

###   变量是左值

一个变量就是一个表达式，其只有一个操作数而没有操作符。变量表达式是左值。因而，**不能将右值引用绑定到一个定义为右值引用的变量上**。如：

```cpp
int &&rr1 = 42;
int &&rr2 = rr1; //错误：rr1 是左值，因而不能这样定义
```

一个变量就是一个左值；不能直接将右值引用绑定到一个变量上，即使这个变量被定义为右值引用类型也不可以。

**但是如果临时对象通过一个接受右值的函数传递给另一个函数时，就会变成左值，因为这个临时对象在传递过程中，变成了命名对象。**

### move库函数

```Cpp
template< class T >                                                                                                                  (C++11 起)
typename std::remove_reference<T>::type&& move( T&& t ) noexcept;         (C++14 前)
```
```Cpp
template< class T >                                                                                                                  (C++14 起)
constexpr typename std::remove_reference<T>::type&& move( T&& t ) noexcept;
```
可以显式将左值强转为对应的右值引用类型，也可以通过调用 `move` 库函数来获取绑定到左值的右值引用，其被定义在 `utility` 头文件中。如：

```cpp
int &&rr3 = std::move(rr1);
```

调用 `move` 告知编译器，以右值方式对象一个左值。特别需要了解的是调用 `move` 将承诺：不会再次使用 `rr1` ，除非是赋值或者析构。当调用了 `move` 之后，**不能对这个对象做任何值上的假设**。可以析构或赋值给移动后的对象，但在此之前不能使用其值。

使用 `move` 的代码应该使用 `std::move` ，而不是 `move`，这样做可以避免潜在的名字冲突。

## 移动构造函数和移动赋值

为了让我们自己的类可以执行移动操作，需要定义移动构造函数和移动赋值操作符。这些成员类似于对应的拷贝赋值操作，但是他们将从给定对象中偷取资源而不是复制。

>1. 参数（右值）**不可以是常量**，因为我们需要修改右值。
2. 参数（右值）的资源链接和标记必须修改。否则，右值的析构函数就会释放资源。转移到新对象的资源也就无效了。

除了移动资源，移动构造函数需要保证移动后的对象的状态是析构无害的。特别是，一旦资源被移动后，原始对象就不再指向移动了的资源，这些所有权被转移给了新创建的对象。如：

```Cpp
StrVec::StrVec(StrVec &&s) noexcept :
    elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    s.elements = s.first_free = s.cap = nullptr;
}
```
与拷贝构造函数不同，移动构造函数并不会分配新资源；其将攫取参数中的内存，在此之后，构造函数体将参数中的指针都设置为 `nullptr`，当一个对象被移动后，这个对象依然存在。最后移动后的对象将被析构，意味着析构函数将在此对象上运行。析构函数将释放其所拥有的资源，**如果没有将指针设置为 `nullptr` 的，就会将移动了的资源给释放掉**。

### 移动操作，库容器和异常

移动操作通常不必自己分配资源，所以移动操作通常不抛出任何异常。当我们写移动操作时，由于其不会抛出异常，我们应当告知编译器这个事实。除非编译器知道这个事实，它将必须做额外的工作来满足移动构造操作将抛出异常。

通过在函数参数列表后加上 `noexcept` ，在构造函数时则，`noexcept` 出现在参数列表后到冒号之间，来告知编译器一个函数不会抛出异常。如：

```Cpp
class StrVec {
public:
    StrVec(StrVec &&) noexcept;
};
StrVec::StrVec(StrVec &&s) noexcept : { ... }
```
必须同时在类体内的声明处和定义处同时指定 `noexcept`。

移动构造函数和移动赋值操作符，如果都不允许抛出异常，那么就应该被指定为 `noexcept`。

告知移动操作不抛出异常是由于两个不相关的事实：第一，尽管移动操作通常不抛出异常，它们可以这样做。第二，有些库容器在元素是否会在构建时抛出异常有不同的表现，**如：`vector` 只有在知道元素类型的移动构造函数不会抛出异常才使用移动构造函数，否则将必须使用拷贝构造函数**；

### 移动赋值操作符

```Cpp
StrVec& StrVec::operator=(StrVec &&rhs) noexcept
{
    if (this == &rhs)
        return *this;
    free();
    elements = rhs.elements;
    first_free = rhs.first_free;
    cap = rhs.cap;

    rhs.elements = rhs.first_free = rhs.cap = nullptr;
    return *this;
}
```

移动赋值操作符不抛出异常应当用 `noexcept` 修饰，与拷贝赋值操作符一样需要警惕自赋值的可能性。移动赋值操作符同时聚合了析构函数和移动构造函数的工作：其将释放左操作数的内存，并且占有右操作数的内存，并将右操作数的指针设为 `nullptr`。

### 移动后的对象必须是可以析构的

移动对象并不会析构那个对象，有时在移动操作完成后，被移动的对象将被销毁。因而，当我们写移动操作时，必须保证移动后的对象的状态是可以析构的。`StrVec` 通过将其指针设置为 `nullptr` 来满足此要求。

除了让对象处于可析构状态，移动操作必须保证对象处于有效状态。通常来说，**有效状态就是可以安全的赋予新值或者使用在不依赖当前值的方式下**。另一方面，移动操作对于遗留在移动后的对象中的值没有什么特别要求，所以，**程序不应该依赖于移动后对象的值**。

例如，从库 `string` 和容器对象中移动资源后，移动后对象的状态将保持有效。可以在移动后对象上调用 `empty` 或 `size` 函数，然而，并不保证得到的结果是空的。可以期望一个移动后对象是空的，但是这并不保证。

以上 `StrVec` 的移动操作将移动后对象留在一个与默认初始化一样的状态。因而，这个 `StrVec` 的所有操作将与默认初始化的 `StrVec` 的操作完全一样。其它类，有着更加复杂的内部结构，也许会表现的不一致。

在移动后操作，移动后对象必须保证在一个有效状态，并且可以析构，**但是用户不能对其值做任何假设**。

### ***合成移动操作**

编译器会为对象合成移动构造函数和移动赋值操作符。然而，在什么情况下合成移动操作与合成拷贝操作是十分不同的。

与拷贝操作不同的，对于某些类来说，编译器根本不合成任何移动操作。特别是，如果一个类定义自己的拷贝构造函数、拷贝赋值操作符或析构函数，移动构造函数和移动赋值操作符是不会合成的。作为结果，有些类是没有移动构造函数或移动赋值操作符。同样，当一个类没有移动操作时，对应的拷贝操作将通过函数匹配被用于替代移动操作。

编译器只会在类没有定义任何拷贝控制成员并且所有的非 static 数据成员都是可移动的情况下才会合成移动构造函数和移动赋值操作符。编译器可以移动内置类型的成员，亦可以移动具有对应移动操作的类类型成员。

移动操作不会隐式被定义为删除的，而是根本不定义，当没有移动构造函数时，重载将选择拷贝构造函数。当用 =default 要求编译器生成时，如果编译器无法移动所有成员，将会生成一个删除的移动操作。被删除的函数不是说不能被用于函数重载，而是说当其是重载解析时最合适的候选函数时，将是编译错误。

* 与拷贝构造函数不同，当类有一个成员定义了自己的拷贝构造函数，但是没有定义移动构造函数时使用拷贝构造函数。当成员没有定义自己的拷贝操作但是编译器无法为其合成移动构造函数时，其移动构造函数被定义为被删除的。对于移动赋值操作符是一样的；
* 如果类有一个成员其移动构造函数或移动赋值操作符是被删除的或不可访问的，其移动构造函数或移动赋值操作符被定义为被删除的；
* 与拷贝构造函数一样，如果其析构函数是被删除的或不可访问的，移动构造函数被定义为被删除的；
* 与拷贝赋值操作符一样，如果其有一个 const 或引用成员，移动赋值操作被定义为删除的；

如果一个类定义自己的移动构造函数或移动赋值操作符，那么合成的拷贝构造函数和拷贝赋值操作符都将被定义为被删除的。

### 右值移动，左值拷贝

当一个类既有移动构造函数又有拷贝构造函数，编译器使用常规的函数匹配来决定使用哪个构造函数。拷贝构造函数通常使用 `const StrVec` 引用类型作为参数，因而，可以匹配可以转为 `StrVec` 类型的对象参数。而移动构造函数则使用 `StrVec &&` 作为参数，因而，只能使用非 `const` 的右值。**如果调用拷贝形式的，需要将参数转为 `const` 的，而移动形式的却是精确匹配，因而，右值将调用移动形式的**。
