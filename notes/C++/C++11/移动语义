# 移动语义

有一些类的资源是__不可共享__的，这种类型的对象可以被移动但不能被拷贝，如：`IO` 或 `unique_ptr`
库容器、`string` 和 `shared_ptr` 支持拷贝和移动，`IO` 和 `unique_ptr` 则只能移动不能拷贝。。

## 右值引用

右值引用是必须绑定到右值的引用，右值引用使用 ``&&`` 符号，相较于左值引用的`` &`` 。右值引用有一个特性就是其只能绑定到**即将销毁**的对象上，因而，可以自由的移动右值引用对象中的资源。

>
左值表示**对象的身份**，而右值表示**对象的值**。不能将左值引用（lvalue reference）绑定到需要转型的值、字面量或者返回右值的表达式上。右值引用则刚好相反：可以将右值引用绑定到以上的值，但不能直接将右值引用绑定到左值。如：

```c++
int i = 42;
int &r = i;
int &&rr = i; //错误：不能将右值引用绑定到左值上
int &r2 = i * 42; //错误：不能将左值引用绑定到右值上
const int &r3 = i * 42; //可以将 const 左值引用绑定到任何类型的值上（const/非 const 的左/右值）
int &&rr2 = i * 42; //将右值引用绑定到右值上
```

返回左值引用的函数和赋值、下标操作、解引用和前缀自增/自减操作符都是返回左值的表达式，可将左值引用绑定到这些表达式的结果中。

返回非引用类型的函数与算术、关系、位操作和后缀自增/自减的操作符都是返回右值的表达式，可将 `const` 左值引用和右值引用绑定到这种表达式上。

###   变量是左值

一个变量就是一个表达式，其只有一个操作数而没有操作符。变量表达式是左值。因而，**不能将右值引用绑定到一个定义为右值引用的变量上**。如：

```cpp
int &&rr1 = 42;
int &&rr2 = rr1; //错误：rr1 是左值，因而不能这样定义
```

一个变量就是一个左值；不能直接将右值引用绑定到一个变量上，即使这个变量被定义为右值引用类型也不可以。

### move库函数

```Cpp
template< class T >                                                                                                                  (C++11 起)
typename std::remove_reference<T>::type&& move( T&& t ) noexcept;         (C++14 前)
```
```Cpp
template< class T >                                                                                                                  (C++14 起)
constexpr typename std::remove_reference<T>::type&& move( T&& t ) noexcept;
```
可以显式将左值强转为对应的右值引用类型，也可以通过调用 `move` 库函数来获取绑定到左值的右值引用，其被定义在 `utility` 头文件中。如：

```cpp
int &&rr3 = std::move(rr1);
```

调用 `move` 告知编译器，以右值方式对象一个左值。特别需要了解的是调用 `move` 将承诺：不会再次使用 `rr1` ，除非是赋值或者析构。当调用了 `move` 之后，**不能对这个对象做任何值上的假设**。可以析构或赋值给移动后的对象，但在此之前不能使用其值。

使用 `move` 的代码应该使用 `std::move` ，而不是 `move`，这样做可以避免潜在的名字冲突。



**但是如果临时对象通过一个接受右值的函数传递给另一个函数时，就会变成左值，因为这个临时对象在传递过程中，变成了命名对象。**



































11
